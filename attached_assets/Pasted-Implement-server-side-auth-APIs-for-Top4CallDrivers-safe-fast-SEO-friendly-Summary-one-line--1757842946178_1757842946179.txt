Implement server-side auth & APIs for Top4CallDrivers (safe, fast, SEO-friendly)

Summary (one line):
Implement the Postman APIs (phone/OTP/login/logout/booking/history) exactly as specified, use secure server-side sessions via httpOnly cookies (JWT or DB-session id), render user info server-side so the header shows Welcome, <name> in the server HTML (visible in View → Page Source), and keep the site fast by avoiding heavy client-side global state (no Redux for auth). Follow the acceptance tests and deliverables below.

1) Absolute rules (must follow)

Do NOT store auth tokens or PII in URL query parameters. Query params can be used for non-sensitive things (utm, filters) — not for auth.

Auth must use an httpOnly cookie set by the server after login (cookie name token by default). Cookie flags: HttpOnly, SameSite=Lax, Secure in production, Path=/.

No Redis or external server session store unless explicitly requested later. Use JWT cookie (stateless) or server DB session id (persisted in DB) — either is fine, but do not add Redis.

The site’s initial HTML must be server-rendered and include the user’s display name when logged in (so View → Page Source shows the name).

Remove/avoid client-side global state for auth (no Redux for session). Small local state for UI components is allowed.

Follow the API contract in the Postman collection exactly — endpoints, methods, request/response shapes and status codes must match.

2) Which router to use

If the repo uses the app/ (app-router): prefer Server Components. Read cookies server-side with cookies() from next/headers and render the header in app/layout.tsx.

If the repo uses pages/ (pages-router): use getServerSideProps on pages that need personalization.

The implementer must detect which router exists (/app vs /pages) and implement accordingly.

3) Auth flow & cookie details (exact)

Login (POST /api/auth/login):

Accepts { phone, otp } or { email, password } as per Postman collection.

Validate credentials (using your DB or the repo’s user store).

On success, create a signed JWT (or server session id) and set cookie:

Set-Cookie: token=<JWT>; HttpOnly; Path=/; Max-Age=604800; Secure=(NODE_ENV==='production'); SameSite=Lax


Response body must follow Postman (status, message); cookie must be set in response headers.

Logout (POST /api/auth/logout):

Clear cookie with Set-Cookie: token=; HttpOnly; Path=/; Max-Age=0; SameSite=Lax.

Response 200 with clear message.

Get current user (GET /api/auth/me or GET /api/me`):

Reads token cookie on server, verifies it and returns { id, name, phone, email } or 401 if not authenticated.

This endpoint is for client usage (SWR/fetch fallback) — but initial greeting must be rendered server-side.

OTP flow (if Postman includes phone/OTP):

POST /api/auth/send-otp — validates phone, sends OTP via configured provider. Return success message.

POST /api/auth/verify-otp — verifies OTP and issues the same cookie as login above.

JWT secret: use JWT_SECRET environment variable. Never hard-code the secret.

Token revocation: Since we avoid Redis, use one of:

Short-lived JWT (e.g., 1 day) + refresh token flow (refresh in httpOnly cookie) — more complex.

Or store token tokenVersion or lastLogoutAt in user DB and check it on verify (this allows revocation without Redis).

Document your choice and reason.

4) Server-side rendering & header behavior (must pass acceptance)

Header must be server-rendered and show Welcome, <FirstName> when cookie is present and valid.

app-router: call server helper in app/layout.tsx (Server Component) and pass user to Header (server component).

pages-router: fetch user in getServerSideProps and pass into page/_app or a layout wrapper.

If header needs client behavior (dropdown, logout button), separate into:

Server-rendered <Header> that prints the name (server HTML).

Small client component HeaderControls for interactivity (logout fetch to /api/auth/logout).

Verify by opening the root URL after login in the browser and checking View → Page Source — it must contain the Welcome, <name> text.

5) API list to implement (map Postman collection)

Implement these endpoints exactly per Postman. If your Postman collection uses slightly different paths/names, use the Postman contract — do not rename routes.

Typical endpoints you must implement (adjust to Postman specifics):

POST /api/auth/send-otp → { phone } -> 200

POST /api/auth/verify-otp → { phone, otp } -> sets cookie

POST /api/auth/login → { phone, password } or { email, password } -> sets cookie

POST /api/auth/logout → clears cookie

GET /api/auth/me → returns current user or 401

POST /api/bookings → create a booking (protected)

GET /api/bookings → list bookings for current user (protected)

GET /api/bookings/:id → booking details (protected)

GET /api/history → user history (protected)

Any other endpoints in Postman (phone validation, driver assignment, fare estimate) — implement per contract.

For all protected endpoints: middleware must verify cookie token server-side and return 401 if missing/invalid.

6) No client-side global state for auth — how to refactor

Remove or stop using Redux for auth/session. If Redux exists, only keep it for non-auth UI features (if necessary) and mark those slices as UI-only.

On pages:

For server-rendered content (greeting, bookings list) render on server using cookie-verified user.

For client-only interactions (live maps), fetch /api/* endpoints (they will verify the same httpOnly cookie).

If client caching is needed, use SWR or React Query sparingly for non-critical UI, but do not reintroduce a global store for auth.

7) Performance & SEO (must do)

Add next.config.js caching headers:

_next/static/* and image assets => Cache-Control: public, max-age=31536000, immutable

HTML pages with personalization => Cache-Control: public, max-age=0, s-maxage=60, stale-while-revalidate=3600 (or custom revalidate).

Use Server Components for static content and only ship minimal client JS.

Use next/image for images; compress images and serve modern formats (WebP/AVIF).

Add next-sitemap and generate sitemap.xml at postbuild.

Add @next/bundle-analyzer for monitoring and run it pre-merge.

Avoid loading analytics synchronously; use Script strategy="afterInteractive".

8) Replit & CI specifics (commands)

Environment variables to add in Replit secrets:

JWT_SECRET (strong random secret)

NODE_ENV (production for secure cookie)

SITE_URL

Any external API keys (SMS provider) from your Postman/Postman env.

Install & run tests in Replit console:

npm ci

# optional: run Postman collection via newman (install global or dev)
npm i -g newman
newman run path/to/postman_collection.json -e path/to/postman_env.json

# compress images (if script exists)
node scripts/compress-images.js

# build
npm run build

# run in production-like mode
npm start   # or next start -p 3000


Include a Github Action or Replit run that executes newman to validate the collection automatically on PRs.

9) Acceptance tests (must pass before merge)

Functional tests (Postman/newman):

POST /api/auth/login with valid credentials → 200 and Set-Cookie header contains token.

GET /api/auth/me with cookie → returns { id, name, ... }.

POST /api/auth/logout → cookie cleared (Max-Age=0) and subsequent GET /api/auth/me returns 401.

Booking endpoints succeed and return 403/401 if no cookie.

Browser tests:

Login via UI or set cookie in browser.

Open site root and View → Page Source — confirm server HTML contains Welcome, <name>.

Reload page — still shows name (cookie persisted).

Click logout — cookie cleared and header shows Sign in.

Performance tests:

Run Lighthouse baseline — aim for Performance >= 85 for core flows, SEO >= 90 where possible.

Run npm run analyze and confirm no single client bundle > 400–500 KB. If found, split or remove offending libs.

Security tests:

Cookie flags verified (HttpOnly, Secure in PROD, SameSite=Lax).

JWT secret not included in client bundles.

No auth tokens in URLs, logs, or localStorage.

10) Deliverables (push to GitHub branch)

Create branch: feature/auth-server-cookie-<yourname> and push all work. Deliver:

New/updated API files: app/api/auth/* or pages/api/auth/*

lib/authServer.ts (server helper)

app/layout.tsx or page wrappers showing server-rendered name and header component

app/components/Header.tsx or components/Header.tsx (server rendering of name)

Updated next.config.js (caching headers + analyzer)

next-sitemap.config.js and package.json scripts (analyze, compress:images, postbuild)

scripts/compress-images.js (image compress script)

ACCEPTANCE.md with step-by-step tests and screenshots

Postman run results or newman output file

Short README entry explaining how to run and environment variables required

Commit guidance:

Separate commits: auth: add login/logout/me endpoints, ui: server-render header, perf: caching headers & sitemap, docs: acceptance tests.

11) Rollback & safety plan

Work in a feature branch; do not merge to main until QA passes.

If issues after merge, revert commit and re-open a PR with fixes.

Keep old code accessible (do not delete until final).

12) Notes for implementer (tips & gotchas)

If you choose stateless JWT, be aware you cannot instantly revoke tokens unless you maintain a revoke list (requires store). Use short tokens and refresh tokens technique if you need revocation.

If user profile changes should be immediate (e.g., logout from server), prefer DB session id approach (but still avoid Redis for now).

Use server-side data fetching to render bookings/history — do not rely on client-side hydration to show the initial list.

For any sensitive third-party API keys (SMS provider), store in Replit secrets and use server-side only.